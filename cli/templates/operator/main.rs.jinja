/// This file is generated by kopgen. Do not edit manually. If you need to make adjustments add it to .openapi-generator-ignore file.
use anyhow::{Context, Result};
use k8s_openapi::apiextensions_apiserver::pkg::apis::apiextensions::v1::CustomResourceDefinition;
use kube::{
    api::{Api, PostParams},
    runtime::wait::{await_condition, conditions},
    Client as KubeClient, CustomResourceExt,
};
use log::{debug, error, info, warn};
use tokio::time::timeout;
use warp::Filter;
use clap::Parser;
use operator::cli::{Cli, Commands};

{% if controllers.len() > 0 %}
use operator::controllers::{{"{"}}
    {% for controller in controllers -%}
        {{ controller }},
     {%- endfor %}
    {{"}"}};
{% endif %}

{% if types.len() > 0 %}
use operator::types::{{"{"}}
    {% for type in types -%}
        {{ type }}::{{ type|capitalize }},
    {%- endfor %}
    {{"}"}};
{% endif %}

async fn deploy_crd(
    kube_client: Api<CustomResourceDefinition>,
    crd: CustomResourceDefinition,
) -> Result<()> {
    let crd_name = crd
        .metadata
        .name
        .clone()
        .unwrap_or_else(|| String::from("Unnamed CRD"));
    info!("Deploying CRD: {}", crd_name);

    let result = kube_client.create(&PostParams::default(), &crd).await;

    match result {
        core::result::Result::Ok(_) => info!("Successfully created CRD: {}", crd_name),
        Err(kube::Error::Api(ae)) if ae.code == 409 => {
            if kube_client
                .replace(&crd_name, &PostParams::default(), &crd)
                .await
                .is_ok()
            {
                info!("Successfully updated CRD: {}", crd_name);
            } else {
                warn!("Failed to update CRD, already exists: {}", crd_name);
            }
        }
        Err(_) => error!("Failed to create CRD: {}", crd_name),
    }

    Ok(())
}

async fn wait_for_crd(kube_client: Api<CustomResourceDefinition>, crd_name: &str) -> Result<()> {
    info!(
        "Waiting for the api-server to accept the CRD of {}...",
        crd_name
    );

    let establish = await_condition(
        kube_client.clone(),
        crd_name,
        conditions::is_crd_established(),
    );
    let _ = timeout(std::time::Duration::from_secs(10), establish).await?;
    info!("CRD of {} is established.", crd_name);
    Ok(())
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    env_logger::init();

    let cli = Cli::parse();

    debug!("Log level: {}", cli.verbosity);

    match cli.command {
        Some(Commands::Run { install_crds }) => {
            info!("Starting operator...");
            debug!("CRD's will be installed automatically: {}", install_crds);

            let kube_client = KubeClient::try_default().await?;
            let kube_client_api: Api<CustomResourceDefinition> = Api::all(kube_client.clone());

            if install_crds {
                info!("Deploying CRDs...");

                let crds = vec![
                    {% for type in types -%}
                    {{ type|capitalize }}::crd(),
                    {%- endfor %}
                ];

                for crd in crds {
                    deploy_crd(kube_client_api.clone(), crd).await?;
                }
            }

            let controllers_crds = vec![
                {% for controller in controllers -%}
                format!("{{ controller }}.{{ api_group}}"),
                {%- endfor %}
            ];
            for controller_crd in controllers_crds {
                if let Err(e) = wait_for_crd(kube_client_api.clone(), &controller_crd).await {
                    error!("Error waiting for CRD {}: {}", &controller_crd, e);
                }
            }

            {% for controller in controllers %}
            // Start the {{ controller }} controller for the {{ controller }}.{{ api_group }}/{{ api_version }} API group
            let {{ controller }}_client = Api::namespaced(kube_client.clone(), "default");
            tokio::spawn(async {
                let _{{ controller }}_controller = {{ controller }}::handle({{ controller }}_client).await;
            });
            {% endfor %}


            tokio::spawn(async {
                let liveness_route = warp::path!("healthz")
                    .map(|| warp::reply::with_status("OK", warp::http::StatusCode::OK));

                let readiness_route = warp::path!("readyz")
                    .map(|| warp::reply::with_status("OK", warp::http::StatusCode::OK));

                let health_routes = liveness_route.or(readiness_route);

                warp::serve(health_routes).run(([0, 0, 0, 0], 8000)).await;
            });
        }
        Some(Commands::Version) => {
            println!("Operator version: {}", env!("CARGO_PKG_VERSION"));
            return Ok(());
        }
        None => {
            error!("No command provided. Use --help for more information.");
            return Err(anyhow::anyhow!(
                "No command provided. Use --help for more information."
            ));
        }
    }

    tokio::signal::ctrl_c()
        .await
        .context("Failed to listen for Ctrl+C")?;
    info!("Termination signal received. Shutting down.");

    Ok(())
}
