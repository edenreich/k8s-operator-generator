// This file is generated by kopgen. Do not edit manually. If you need to make adjustments add it to .openapi-generator-ignore file.
use anyhow::Context;
use clap::Parser;
use k8s_openapi::apiextensions_apiserver::pkg::apis::apiextensions::v1::CustomResourceDefinition;
use kube::{api::Api, Client as KubeClient, CustomResourceExt};
use log::{debug, error, info};
use operator::{
    cli::{Cli, Commands},
    deploy_crd{% if controllers.len() > 0 %}, wait_for_crd{% endif %}
};
use warp::Filter;
{% if controllers.len() > 0 %}
use operator::controllers::{{"{"}}
    {%- for controller in controllers %}
        {{ controller }},
     {%- endfor %}
{{"}"}};
{% endif %}
{%- if types.len() > 0 %}
use operator::types::{{"{"}}
    {%- for type in types %}
        {{ type }}::{{ type|capitalize }},
    {%- endfor %}
{{"}"}};
{% endif %}
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    env_logger::init();

    let cli = Cli::parse();

    debug!("Log level: {}", cli.verbosity);

    match cli.command {
        Some(Commands::Run { install_crds }) => {
            info!("Starting operator...");
            debug!("CRD's will be installed automatically: {}", install_crds);

            let kube_client = KubeClient::try_default().await?;
            let kube_client_api: Api<CustomResourceDefinition> = Api::all(kube_client.clone());

            if install_crds {
                info!("Deploying CRDs...");

                let crds = vec![{% if types.len() > 0 %}
                    {%- for type in types %}
                    {{ type|capitalize }}::crd(),
                    {%- endfor %}
                {% endif %}];

                for crd in crds {
                    deploy_crd(kube_client_api.clone(), crd).await?;
                }
            }
{% if controllers.len() > 0 %}
            let controllers_crds = vec![
                {%- for controller in controllers %}
                format!("{{ controller }}.{{ api_group}}"),
                {%- endfor %}
            ];
            for controller_crd in controllers_crds {
                if let Err(e) = wait_for_crd(kube_client_api.clone(), &controller_crd).await {
                    error!("Error waiting for CRD {}: {}", &controller_crd, e);
                }
            }
{% else %}
            debug!("No controllers to start. Please check your configuration. KUBERNETES_OPERATOR_INCLUDE_TAGS is possibly empty.");
{% endif -%}
{%- for controller in controllers %}
            // Start the {{ controller }} controller for the {{ controller }}.{{ api_group }}/{{ api_version }} API group
            let {{ controller }}_client = Api::namespaced(kube_client.clone(), "default");
            tokio::spawn(async {
                let _{{ controller }}_controller = {{ controller }}::handle({{ controller }}_client).await;
            });
{% endfor %}
            tokio::spawn(async {
                let liveness_route = warp::path!("healthz")
                    .map(|| warp::reply::with_status("OK", warp::http::StatusCode::OK));

                let readiness_route = warp::path!("readyz")
                    .map(|| warp::reply::with_status("OK", warp::http::StatusCode::OK));

                let health_routes = liveness_route.or(readiness_route);

                warp::serve(health_routes).run(([0, 0, 0, 0], 8000)).await;
            });
        }
        Some(Commands::Version) => {
            println!("Operator version: {}", env!("CARGO_PKG_VERSION"));
            return Ok(());
        }
        None => {
            error!("No command provided. Use --help for more information.");
            return Err(anyhow::anyhow!(
                "No command provided. Use --help for more information."
            ));
        }
    }

    tokio::signal::ctrl_c()
        .await
        .context("Failed to listen for Ctrl+C")?;
    info!("Termination signal received. Shutting down.");

    Ok(())
}
