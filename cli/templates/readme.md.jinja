# ðŸ¦€ {{ project_name }} ðŸ¦€

This Kubernetes Operator is generated by [kopgen](https://github.com/edenreich/kopgen).

- [ðŸ¦€ {{ project_name }} ðŸ¦€](#-{{ project_name|dashcase }}-)
  - [Documentation](#documentation)
  - [Quick Start Guide](#quick-start-guide)

## Documentation

The documentation is available here: https://edenreich.github.io/kopgen/introduction.html

## Quick Start Guide

Before you proceed, ensure that [Docker](https://docs.docker.com/engine/install/) is installed on your system.

Download and install the latest `kopgen` CLI, if you haven't already:

```sh
curl -sSL https://raw.githubusercontent.com/edenreich/kopgen/refs/heads/main/scripts/install.sh | sh
```

It is recommended to initialize a new Git repository and commit the generated code changes. This practice helps you effectively track code modifications.

1. Configure the project:

```sh
cp .env.example .env
```

2. Make the needed adjustment to OpenAPI specification and generate the project assets based on it:

```sh
task generate
```

Behind the scenes, this command will download the OpenAPI specification and generate the project assets based on it.
It will also generate an SDK for the API client and the operator code and manifests.
In addition, it will append the CRD's in a form of rust code to crdgen so the CRD's can be generated and placed in `manifests/crds` directory.
If you're curious, you can see more about what `task generate` is executing by opening the [Taskfile.yml](Taskfile.yml).

3. Happy with the code changes? Commit them to your repository:

```sh
git commit -am "feat: generated project assets"
```

Not happy with the generated code? adjust the controllers code in [operator/src/controllers](operator/src/controllers) add the file path to [.openapi-generator-ignore](.openapi-generator-ignore) so the code will not be overwritten.

5. Create a local Kubernetes cluster:

```sh
task cluster-create
```

6. Run the operator:

```sh
task run
```

7. Iterate over step 2

In this way you are following the documentation driven development approach, where you first write the documentation for the endpoints and then implement them with the generated code.
