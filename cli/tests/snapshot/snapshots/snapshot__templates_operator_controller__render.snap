---
source: cli/tests/snapshot/templates_operator_controller.rs
expression: rendered
---
// This file is generated by kopgen. Do not edit manually. If you need to make adjustments add it to .openapi-generator-ignore file.
use std::{sync::Arc, time::Duration};

use futures::StreamExt;
use kube::api::{Api, PostParams, Resource};
use kube_runtime::{controller::Action, watcher, Controller};
use log::{error, info, warn};

use openapi::{
    apis::{
        example_tag_api::{
            create_argName,
            delete_argName_by_id,
            get_argName_by_id,
            update_argName_by_id
        },
        configuration::Configuration,
    },
    models::ExampleKind as ExampleKindDto,
};

use crate::{
    errors::OperatorError,
    types::argName::{
        ExampleKind,
        ExampleKindSpec,
        ExampleKindStatus,
    },
    {add_finalizer, create_condition, remove_finalizer, update_status},
};

const REQUEUE_AFTER_IN_SEC: u64 = 30;
const API_URL: &str = "https://api.example.com";
const API_USER_AGENT: &str = "k8s-operator";

struct ExtraArgs {
    kube_client: Api<ExampleKind>,
}

pub async fn handle(kube_client: Api<ExampleKind>) -> Result<(), OperatorError> {
    info!("Starting the controller");
    let controller = Controller::new(kube_client.clone(), watcher::Config::default());

    let extra_args = Arc::new(ExtraArgs {
        kube_client: kube_client.clone(),
    });

    info!("Running the controller");
    controller
        .run(reconcile, error_policy, extra_args)
        .for_each(|res| async {
            match res {
                Ok(action) => info!("Reconciliation was successful, action: {:?}", action),
                Err(e) => error!("Error reconciling: {:?}", e),
            }
        })
        .await;

    info!("ExampleKind Controller has stopped");
    Ok(())
}

async fn reconcile(argName: Arc<ExampleKind>, ctx: Arc<ExtraArgs>) -> Result<Action, OperatorError> {
    let kube_client = ctx.kube_client.clone();
    let mut argName = argName.as_ref().clone();
    let resourceRef = argName
        .status
        .as_ref()
        .and_then(|status| status.resourceRef.clone())
        .unwrap_or_default();

    if argName.status.is_none() {
        add_default_status(&kube_client, &mut argName).await?;
    }

    if argName.meta().deletion_timestamp.is_some() {
        handle_delete(&kube_client, &mut argName, &resourceRef).await?;
    } else if resourceRef.is_empty() {
        handle_create(&kube_client, &mut argName).await?;
    } else if argName.meta().generation != argName.status.as_ref().unwrap().observed_generation {
        handle_update(&kube_client, &mut argName, &resourceRef).await?;
    }

    check_for_drift(&kube_client, &mut argName).await?;
    Ok(Action::requeue(Duration::from_secs(REQUEUE_AFTER_IN_SEC)))
}

async fn get_client_config() -> Result<Configuration, OperatorError> {
    let config = Configuration {
        base_path: API_URL.to_string(),
        client: reqwest::Client::new(),
        user_agent: Some(API_USER_AGENT.to_string()),
        bearer_access_token: Some(std::env::var("ACCESS_TOKEN").unwrap_or_default()),
        ..Default::default()
    };
    Ok(config)
}

async fn add_default_status(kube_client: &Api<ExampleKind>, argName: &mut ExampleKind) -> Result<(), OperatorError> {
    argName.status = Some(ExampleKindStatus {
        conditions: vec![],
        resourceRef: None,
        observed_generation: Some(0),
    });
    update_status(kube_client, argName.clone())
        .await
        .map_err(|e| OperatorError::FailedToUpdateStatus(e.into()))
}

pub async fn check_for_drift(
    kube_client: &Api<ExampleKind>,
    argName: &mut ExampleKind,
) -> Result<(), OperatorError> {
    let dto = converters::kube_type_to_dto(argName.clone());
    let resourceRef = converters::resourceRef_to_string(dto.resourceRef).unwrap_or_default();
    let config = get_client_config().await?;

    if resourceRef.is_empty() {
        warn!("ExampleKind has no status, cannot get by id or check for drift. Skipping...");
        return Ok(());
    }

    match get_argName_by_id(&config, &resourceRef).await {
        Ok(dto) => {
            let remote_argName = converters::dto_to_kube_type(dto);
            if remote_argName != argName.spec {
                let current_argName_dto = converters::kube_type_to_dto(argName.clone());
                warn!("ExampleKind has drifted remotely, sending an update to remote...");
                match update_argName_by_id(&config, &resourceRef, current_argName_dto).await {
                    Ok(_) => {
                        info!("ExampleKind updated successfully");
                        let condition = create_condition(
                            "Updated",
                            "AvailableUpdated",
                            "Updated the resource",
                            "Resource has been updated",
                            argName.meta().generation,
                        );
                        let mut argName_clone = argName.clone();
                        if let Some(status) = argName_clone.status.as_mut() {
                            status.conditions.push(condition);
                            status.observed_generation = argName.meta().generation;
                        }
                        update_status(kube_client, argName_clone).await?
                    }
                    Err(e) => {
                        error!("Failed to update ExampleKind: {:?}", e);
                        return Err(OperatorError::FailedToGetResource(e.into()));
                    }
                }
            }
        }
        Err(e) => {
            error!("Failed to get ExampleKind: {:?}", e);
            return Err(OperatorError::FailedToGetResource(e.into()));
        }
    }

    Ok(())
}

fn error_policy(_resource: Arc<ExampleKind>, error: &OperatorError, _ctx: Arc<ExtraArgs>) -> Action {
    error!("Error processing event: {:?}", error);
    Action::requeue(Duration::from_secs(REQUEUE_AFTER_IN_SEC))
}

mod converters {
    use super::{
        ExampleKind, ExampleKindDto, ExampleKindSpec
    };

    pub fn resourceRef_to_string(resourceRef: Option<resourceRef::Uuid>) -> Option<String> {
        resourceRef.map(|resourceRef| resourceRef.to_string())
    }

    fn string_to_resourceRef(resourceRef: Option<String>) -> Option<resourceRef::Uuid> {
        match resourceRef {
            Some(resourceRef) => match resourceRef::Uuid::parse_str(&resourceRef) {
                Ok(resourceRef) => Some(resourceRef),
                Err(_) => None,
            },
            None => None,
        }
    }

    pub fn kube_type_to_dto(argName: ExampleKind) -> ExampleKindDto {
        let resourceRef = match argName.status {
            Some(status) => string_to_resourceRef(status.resourceRef),
            None => None,
        };
        ExampleKindDto {
            resourceRef,
                field1: argName.spec.field1,
                field2: argName.spec.field2,
        }
    }

    pub fn dto_to_kube_type(argName: ExampleKindDto) -> ExampleKindSpec {
        ExampleKindSpec {
            field1: argName.field1,
            field2: argName.field2,
        }
    }
}
