---
source: cli/tests/snapshot/templates_operator_lib.rs
expression: rendered
---
// This file is generated by kopgen. Do not edit manually. If you need to make adjustments add it to .openapi-generator-ignore file.
pub mod cli;
pub mod controllers;
pub mod errors;
pub mod types;

use crate::errors::OperatorError;
use core::fmt::Debug;
use futures_util::stream::StreamExt;
use k8s_openapi::{
    api::core::v1::{Event, EventSource, ObjectReference},
    apiextensions_apiserver::pkg::apis::apiextensions::v1::CustomResourceDefinition,
    apimachinery::pkg::apis::meta::v1::{Condition, Time},
    chrono,
};
use kube::{
    api::{Api, ObjectMeta, Patch, PatchParams, PostParams, WatchEvent, WatchParams},
    core::CustomResourceExt,
    Error, Resource, ResourceExt,
};
use kube_runtime::{conditions, wait::await_condition};
use log::{debug, error, info, warn};
use openapi::apis::configuration::Configuration;
use serde::{de::DeserializeOwned, Serialize};
use serde_json::json;
use std::sync::Arc;
use tokio::time::{sleep, timeout, Duration};

pub async fn watch_resource<T>(
    config: Arc<Configuration>,
    kubernetes_api: Api<T>,
    watch_params: WatchParams,
    handler: fn(Arc<Configuration>, WatchEvent<T>, Api<T>),
) -> anyhow::Result<(), OperatorError>
where
    T: Clone + core::fmt::Debug + DeserializeOwned + 'static,
{
    let mut stream = kubernetes_api
        .watch(&watch_params, "0")
        .await
        .map_err(|e| OperatorError::FailedToWatchResources(e.into()))?
        .boxed();
    loop {
        while let Some(event) = stream.next().await {
            match event {
                Ok(event) => handler(Arc::clone(&config), event, kubernetes_api.clone()),
                Err(e) => error!("Error watching resource: {:?}", e),
            }
        }
        sleep(Duration::from_secs(1)).await;
        stream = kubernetes_api
            .watch(&watch_params, "0")
            .await
            .map_err(|e| OperatorError::FailedToWatchResources(e.into()))?
            .boxed();
    }
}

pub async fn add_finalizer<T>(resource: &mut T, kubernetes_api: Api<T>) -> Result<(), OperatorError>
where
    T: Clone
        + Serialize
        + DeserializeOwned
        + Resource
        + CustomResourceExt
        + core::fmt::Debug
        + 'static,
{
    let finalizer = format!("finalizers.{}", "example.com");
    let finalizers = resource.meta_mut().finalizers.get_or_insert_with(Vec::new);
    if finalizers.contains(&finalizer) {
        debug!("Finalizer already exists");
        return Ok(());
    }
    finalizers.push(finalizer);
    let resource_name = resource.meta_mut().name.clone().unwrap();
    let resource_clone = resource.clone();
    let patch = Patch::Merge(&resource_clone);
    let patch_params = PatchParams {
        field_manager: resource.meta_mut().name.clone(),
        ..Default::default()
    };

    kubernetes_api
        .patch(&resource_name, &patch_params, &patch)
        .await
        .map_err(|e| {
            error!("Failed to add finalizer: {:?}", e);
            OperatorError::FailedToPatchResource(e.into())
        })?;

    Ok(())
}

pub async fn remove_finalizer<T>(
    resource: &mut T,
    kubernetes_api: Api<T>,
) -> Result<(), OperatorError>
where
    T: Clone + Serialize + DeserializeOwned + Resource + CustomResourceExt + Debug + 'static,
{
    let finalizer = format!("finalizers.{}", "example.com");
    let finalizers = match &mut resource.meta_mut().finalizers {
        Some(finalizers) => finalizers,
        None => return Ok(()),
    };

    if !finalizers.contains(&finalizer) {
        return Ok(());
    }

    finalizers.retain(|f| f != &finalizer);
    let patch = json ! ({ "metadata" : { "finalizers" : finalizers } });
    let patch = Patch::Merge(&patch);
    let patch_params = PatchParams {
        field_manager: resource.meta_mut().name.clone(),
        ..Default::default()
    };

    kubernetes_api
        .patch(
            &resource.clone().meta_mut().name.clone().unwrap(),
            &patch_params,
            &patch,
        )
        .await
        .map_err(|e| {
            error!("Failed to remove finalizer: {:?}", e);
            OperatorError::FailedToPatchResource(e.into())
        })?;

    Ok(())
}

pub async fn add_event<T>(
    kind: String,
    resource: &mut T,
    reason: &str,
    from: &str,
    message: &str,
) -> Result<(), OperatorError>
where
    T: CustomResourceExt
        + Clone
        + Serialize
        + DeserializeOwned
        + Resource
        + core::fmt::Debug
        + 'static,
{
    let kube_client = kube::Client::try_default()
        .await
        .map_err(|e| OperatorError::FailedToCreateClient(e.into()))?;
    let namespace = resource.namespace().clone().unwrap_or_default();
    let kubernetes_api: Api<Event> = Api::namespaced(kube_client.clone(), &namespace);
    let resource_ref = ObjectReference {
        kind: Some(kind),
        namespace: resource.namespace().clone(),
        name: Some(resource.meta().name.clone().unwrap()),
        uid: resource.uid().clone(),
        ..Default::default()
    };
    let timestamp = chrono::Utc::now().to_rfc3339();
    let event_name = format!("{}-{}", resource.meta().name.clone().unwrap(), timestamp);
    let new_event = Event {
        metadata: ObjectMeta {
            name: Some(event_name),
            ..Default::default()
        },
        involved_object: resource_ref,
        reason: Some(reason.into()),
        message: Some(message.into()),
        type_: Some("Normal".into()),
        source: Some(EventSource {
            component: Some(String::from(from)),
            ..Default::default()
        }),
        first_timestamp: Some(Time(chrono::Utc::now())),
        last_timestamp: Some(Time(chrono::Utc::now())),
        ..Default::default()
    };
    match kubernetes_api
        .create(&PostParams::default(), &new_event)
        .await
    {
        Ok(_) => {
            debug!("Event added successfully");
            Ok(())
        }
        Err(e) => {
            error!("Failed to add event: {:?}", e);
            Err(OperatorError::FailedToAddEvent(e.into()))
        }
    }
}

pub fn create_condition(
    status: &str,
    type_: &str,
    reason: &str,
    message: &str,
    observed_generation: Option<i64>,
) -> Condition {
    Condition {
        last_transition_time: Time(chrono::Utc::now()),
        message: message.to_string(),
        reason: reason.to_string(),
        status: status.to_string(),
        type_: type_.to_string(),
        observed_generation,
    }
}

pub async fn update_status<T>(kubernetes_api: &Api<T>, status: T) -> Result<(), OperatorError>
where
    T: Resource<DynamicType = ()> + Serialize + Clone + DeserializeOwned,
{
    let resource_name = status
        .meta()
        .name
        .clone()
        .ok_or_else(|| anyhow::anyhow!("Resource name is missing"))?;

    let status_replace_bytes =
        serde_json::to_vec(&status).map_err(|e| OperatorError::FailedToUpdateStatus(e.into()))?;

    let post_params = PostParams::default();

    match kubernetes_api
        .replace_status(&resource_name, &post_params, status_replace_bytes.clone())
        .await
    {
        Ok(_) => {
            info!("Status updated successfully for {}", resource_name);
            Ok(())
        }
        Err(Error::Api(ae)) if ae.code == 409 => {
            info!(
                "Conflict updating status for {}, retrying...",
                resource_name
            );
            sleep(Duration::from_secs(1)).await;
            Err(OperatorError::FailedToUpdateStatus(anyhow::anyhow!(
                "Conflict updating status for {}",
                resource_name
            )))
        }
        Err(e) => Err(OperatorError::FailedToUpdateStatus(anyhow::anyhow!(
            "Failed to update status for {}: {:?}",
            resource_name,
            e
        ))),
    }
}

pub async fn deploy_crd(
    kube_client: Api<CustomResourceDefinition>,
    crd: CustomResourceDefinition,
) -> Result<(), OperatorError> {
    let crd_name = crd
        .metadata
        .name
        .clone()
        .unwrap_or_else(|| String::from("Unnamed CRD"));
    info!("Deploying CRD: {}", crd_name);

    let result = kube_client.create(&PostParams::default(), &crd).await;

    match result {
        core::result::Result::Ok(_) => info!("Successfully created CRD: {}", crd_name),
        Err(kube::Error::Api(ae)) if ae.code == 409 => {
            if kube_client
                .replace(&crd_name, &PostParams::default(), &crd)
                .await
                .is_ok()
            {
                info!("Successfully updated CRD: {}", crd_name);
            } else {
                warn!("Failed to update CRD, already exists: {}", crd_name);
            }
        }
        Err(_) => error!("Failed to create CRD: {}", crd_name),
    }

    Ok(())
}

pub async fn wait_for_crd(
    kube_client: Api<CustomResourceDefinition>,
    crd_name: &str,
) -> Result<(), OperatorError> {
    info!(
        "Waiting for the api-server to accept the CRD of {}...",
        crd_name
    );

    let establish = await_condition(
        kube_client.clone(),
        crd_name,
        conditions::is_crd_established(),
    );
    let _ = timeout(std::time::Duration::from_secs(10), establish)
        .await
        .map_err(|e| OperatorError::AnyhowError(e.into()))?;
    info!("CRD of {} is established.", crd_name);
    Ok(())
}
