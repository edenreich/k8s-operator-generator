use crate::{
    add_event,
    add_finalizer,
    change_status,
    remove_finalizer,
    types::{{ arg_name }}::{{ type_name }},
};
use kube::{
    Resource,
    api::{
        Api,
        WatchEvent,
    }
};
use log::{
    error,
    info,
};
use openapi::apis::configuration::Configuration;
use openapi::apis::{{ tag_name }}_api::create_{{ arg_name }};
use openapi::apis::{{ tag_name }}_api::delete_{{ arg_name }}_by_id;
use openapi::apis::{{ tag_name }}_api::update_{{ arg_name }}_by_id;
use openapi::models::{{ type_name }} as {{ type_name }}Dto;
use std::sync::Arc;

fn convert_to_dto({{ arg_name }}: {{ type_name }}) -> {{ type_name }}Dto {
    let {{ reference_id }} = match {{ arg_name }}.status {
        Some(status) => status.{{ reference_id }},
        None => None,
    };
    {{ type_name }}Dto {
        {{ reference_id }}: {{ reference_id }},
         {%- for field in fields %}
         {{ field.pub_name }}: {{ arg_name }}.spec.{{ field.pub_name }},
         {%- endfor %}
    }
}

pub async fn handle(
    config: Arc<Configuration>,
    event: WatchEvent<{{ type_name }}>,
    kubernetes_api: Api<{{ type_name }}>,
) {
    let kind = {{ type_name }}::kind(&());
    let kind_str = kind.to_string();
    match event {
        WatchEvent::Added(mut {{ arg_name }}) => {
        handle_added(&config, kind_str, &mut {{ arg_name }}, kubernetes_api).await
        }
        WatchEvent::Modified(mut {{ arg_name }}) => {
            handle_modified(&config, kind_str, &mut {{ arg_name }}, kubernetes_api).await
        }
        WatchEvent::Bookmark(bookmark) => {
            info!("{{ type_name }} Bookmark: {:?}", bookmark.metadata.resource_version);
            return;
        }
        _ => {
            info!("{{ type_name }} Unknown event {:?}", event);
            return;
        }
    };
}

pub async fn handle_added(
    config: &Configuration,
    kind_str: String,
    {{ arg_name }}: &mut {{ type_name }},
    kubernetes_api: Api<{{ type_name }}>,
) {
    if {{ arg_name }}.metadata.deletion_timestamp.is_some() {
        handle_deleted(config, kind_str, {{ arg_name }}, kubernetes_api).await;
        return;
    }
    if {{ arg_name }}.status.is_none() {
        {{ arg_name }}.status = Some(Default::default());
    }
    let model = {{ arg_name }}.clone();
    let name = {{ arg_name }}.metadata.name.clone().unwrap();
    let dto = convert_to_dto(model);
    if dto.{{ reference_id }}.is_some() {
        info!("{} {} already exists", kind_str, name);
        return;
    }
    add_finalizer({{ arg_name }}, kubernetes_api.clone()).await;
    match create_{{ arg_name }}(config, dto).await {
        Ok(resp) => {
            info!("{} {} created", kind_str, name);
            change_status({{ arg_name }}, kubernetes_api.clone(), "{{ reference_id }}", resp.{{ reference_id }}.unwrap()).await;
            add_event(kind_str, {{ arg_name }}, "Normal", "{{ arg_name }}", "{{ type_name }} created").await;
        }
        Err(e) => {
            error!("Failed to create {} {}: {:?}", kind_str, name, e);
            remove_finalizer({{ arg_name }}, kubernetes_api.clone()).await;
        }
    };
}
            
pub async fn handle_modified(
    config: &Configuration,
    kind_str: String,
    {{ arg_name }}: &mut {{ type_name }},
    kubernetes_api: Api<{{ type_name }}>,
) {
    if {{ arg_name }}.metadata.deletion_timestamp.is_some() {
        handle_deleted(config, kind_str, {{ arg_name }}, kubernetes_api).await;
        return;
    }
    if {{ arg_name }}.status.is_none() {
        {{ arg_name }}.status = Some(Default::default());
    }
    let model = {{ arg_name }}.clone();
    let name = {{ arg_name }}.metadata.name.clone().unwrap();
    let dto = convert_to_dto(model);
    if dto.{{ reference_id }}.is_none() {
        info!("{} {} does not exist", kind_str, name);
        return;
    }
    let dto_clone = dto.clone();
    match update_{{ arg_name }}_by_id(config, &dto.{{ reference_id }}.unwrap(), dto_clone).await {
        Ok(_) => {
            let msg = format!("{} {} updated", kind_str.clone(), name);
            info!("{}", msg);
            add_event(kind_str.clone(), {{ arg_name }}, "Normal", &kind_str.clone(), &msg).await;
        }
        Err(e) => {
            let msg = format!("Failed to update {} {}: {:?}", kind_str.clone(), name, e);
            error!("{}", msg);
            add_event(kind_str.clone(), {{ arg_name }}, "Error", &kind_str.clone(), &msg).await;
        }
    };
}

pub async fn handle_deleted(
    config: &Configuration,
    kind_str: String,
    {{ arg_name }}: &mut {{ type_name }},
    _kubernetes_api: Api<{{ type_name }}>,
) {
    let name = {{ arg_name }}.metadata.name.clone().unwrap();
    match delete_{{ arg_name }}_by_id(config, &{{ arg_name }}.metadata.name.clone().unwrap()).await {
        Ok(_) => {
            info!("{} {} deleted", kind_str, name);
            add_event(kind_str, {{ arg_name }}, "Normal", "{{ arg_name }}", "{{ type_name }} deleted").await;
        }
        Err(e) => {
            error!("Failed to delete {} {}: {:?}", kind_str, name, e);
            add_event(
                kind_str,
                {{ arg_name }},
                "Error",
                "{{ arg_name }}",
                "Failed to delete {} {} remotely",
            )
            .await;
        }
    };
}
